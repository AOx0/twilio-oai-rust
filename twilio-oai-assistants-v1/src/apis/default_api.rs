/*
 * Twilio - Assistants
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`create_assistant`]
#[derive(Clone, Debug)]
pub struct CreateAssistantParams {
    pub assistants_period_v1_period_service_period_create_assistant_request: models::AssistantsPeriodV1PeriodServicePeriodCreateAssistantRequest
}

/// struct for passing parameters to the method [`create_assistant_knowledge_attachment`]
#[derive(Clone, Debug)]
pub struct CreateAssistantKnowledgeAttachmentParams {
    /// The assistant ID.
    pub assistant_id: String,
    /// The knowledge ID.
    pub id: String
}

/// struct for passing parameters to the method [`create_assistant_tool_attachment`]
#[derive(Clone, Debug)]
pub struct CreateAssistantToolAttachmentParams {
    /// The assistant ID.
    pub assistant_id: String,
    /// The tool ID.
    pub id: String
}

/// struct for passing parameters to the method [`create_feedback`]
#[derive(Clone, Debug)]
pub struct CreateFeedbackParams {
    /// The assistant ID.
    pub id: String,
    pub assistants_period_v1_period_service_period_create_feedback_request: models::AssistantsPeriodV1PeriodServicePeriodCreateFeedbackRequest
}

/// struct for passing parameters to the method [`create_knowledge`]
#[derive(Clone, Debug)]
pub struct CreateKnowledgeParams {
    pub assistants_period_v1_period_service_period_create_knowledge_request: models::AssistantsPeriodV1PeriodServicePeriodCreateKnowledgeRequest
}

/// struct for passing parameters to the method [`create_message`]
#[derive(Clone, Debug)]
pub struct CreateMessageParams {
    /// the Assistant ID.
    pub id: String,
    pub assistants_period_v1_period_service_period_assistant_send_message_request: models::AssistantsPeriodV1PeriodServicePeriodAssistantSendMessageRequest
}

/// struct for passing parameters to the method [`create_tool`]
#[derive(Clone, Debug)]
pub struct CreateToolParams {
    pub assistants_period_v1_period_service_period_create_tool_request: models::AssistantsPeriodV1PeriodServicePeriodCreateToolRequest
}

/// struct for passing parameters to the method [`delete_assistant`]
#[derive(Clone, Debug)]
pub struct DeleteAssistantParams {
    pub id: String
}

/// struct for passing parameters to the method [`delete_assistant_knowledge_attachment`]
#[derive(Clone, Debug)]
pub struct DeleteAssistantKnowledgeAttachmentParams {
    /// The assistant ID.
    pub assistant_id: String,
    /// The knowledge ID.
    pub id: String
}

/// struct for passing parameters to the method [`delete_assistant_tool_attachment`]
#[derive(Clone, Debug)]
pub struct DeleteAssistantToolAttachmentParams {
    /// The assistant ID.
    pub assistant_id: String,
    /// The tool ID.
    pub id: String
}

/// struct for passing parameters to the method [`delete_knowledge`]
#[derive(Clone, Debug)]
pub struct DeleteKnowledgeParams {
    /// the Knowledge ID.
    pub id: String
}

/// struct for passing parameters to the method [`delete_tool`]
#[derive(Clone, Debug)]
pub struct DeleteToolParams {
    /// The tool ID.
    pub id: String
}

/// struct for passing parameters to the method [`fetch_assistant`]
#[derive(Clone, Debug)]
pub struct FetchAssistantParams {
    pub id: String
}

/// struct for passing parameters to the method [`fetch_knowledge`]
#[derive(Clone, Debug)]
pub struct FetchKnowledgeParams {
    pub id: String
}

/// struct for passing parameters to the method [`fetch_knowledge_status`]
#[derive(Clone, Debug)]
pub struct FetchKnowledgeStatusParams {
    /// the Knowledge ID.
    pub id: String
}

/// struct for passing parameters to the method [`fetch_session`]
#[derive(Clone, Debug)]
pub struct FetchSessionParams {
    pub id: String
}

/// struct for passing parameters to the method [`fetch_tool`]
#[derive(Clone, Debug)]
pub struct FetchToolParams {
    pub id: String
}

/// struct for passing parameters to the method [`list_assistants`]
#[derive(Clone, Debug)]
pub struct ListAssistantsParams {
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`list_feedback`]
#[derive(Clone, Debug)]
pub struct ListFeedbackParams {
    /// The assistant ID.
    pub id: String,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`list_knowledge`]
#[derive(Clone, Debug)]
pub struct ListKnowledgeParams {
    pub assistant_id: Option<String>,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`list_knowledge_by_assistant`]
#[derive(Clone, Debug)]
pub struct ListKnowledgeByAssistantParams {
    /// The assistant ID.
    pub assistant_id: String,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`list_knowledge_chunks`]
#[derive(Clone, Debug)]
pub struct ListKnowledgeChunksParams {
    /// The knowledge ID.
    pub id: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`list_messages`]
#[derive(Clone, Debug)]
pub struct ListMessagesParams {
    /// Session id or name
    pub session_id: String,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`list_policies`]
#[derive(Clone, Debug)]
pub struct ListPoliciesParams {
    /// The tool ID.
    pub tool_id: Option<String>,
    /// The knowledge ID.
    pub knowledge_id: Option<String>,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`list_sessions`]
#[derive(Clone, Debug)]
pub struct ListSessionsParams {
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`list_tools`]
#[derive(Clone, Debug)]
pub struct ListToolsParams {
    pub assistant_id: Option<String>,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`list_tools_by_assistant`]
#[derive(Clone, Debug)]
pub struct ListToolsByAssistantParams {
    /// The assistant ID.
    pub assistant_id: String,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`update_assistant`]
#[derive(Clone, Debug)]
pub struct UpdateAssistantParams {
    pub id: String,
    pub assistants_period_v1_period_service_period_update_assistant_request: Option<models::AssistantsPeriodV1PeriodServicePeriodUpdateAssistantRequest>
}

/// struct for passing parameters to the method [`update_knowledge`]
#[derive(Clone, Debug)]
pub struct UpdateKnowledgeParams {
    pub id: String,
    pub assistants_period_v1_period_service_period_update_knowledge_request: Option<models::AssistantsPeriodV1PeriodServicePeriodUpdateKnowledgeRequest>
}

/// struct for passing parameters to the method [`update_tool`]
#[derive(Clone, Debug)]
pub struct UpdateToolParams {
    pub id: String,
    pub assistants_period_v1_period_service_period_update_tool_request: Option<models::AssistantsPeriodV1PeriodServicePeriodUpdateToolRequest>
}


/// struct for typed successes of method [`create_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssistantSuccess {
    Status201(models::AssistantsPeriodV1PeriodServicePeriodAssistant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_assistant_knowledge_attachment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssistantKnowledgeAttachmentSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_assistant_tool_attachment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssistantToolAttachmentSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_feedback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFeedbackSuccess {
    Status201(models::AssistantsPeriodV1PeriodServicePeriodFeedback),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_knowledge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateKnowledgeSuccess {
    Status201(models::AssistantsPeriodV1PeriodServicePeriodKnowledge),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageSuccess {
    Status200(models::AssistantsPeriodV1PeriodServicePeriodAssistantSendMessageResponse),
    Status202(models::AssistantsPeriodV1PeriodServicePeriodAssistantSendMessageResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_tool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateToolSuccess {
    Status201(models::AssistantsPeriodV1PeriodServicePeriodTool),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAssistantSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_assistant_knowledge_attachment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAssistantKnowledgeAttachmentSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_assistant_tool_attachment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAssistantToolAttachmentSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_knowledge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteKnowledgeSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_tool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteToolSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAssistantSuccess {
    Status200(models::AssistantsPeriodV1PeriodServicePeriodAssistantWithToolsAndKnowledge),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_knowledge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchKnowledgeSuccess {
    Status200(models::AssistantsPeriodV1PeriodServicePeriodKnowledge),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_knowledge_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchKnowledgeStatusSuccess {
    Status200(models::AssistantsPeriodV1PeriodServicePeriodKnowledgeStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSessionSuccess {
    Status200(models::AssistantsPeriodV1PeriodServicePeriodSession),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_tool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchToolSuccess {
    Status200(models::AssistantsPeriodV1PeriodServicePeriodToolWithPolicies),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_assistants`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAssistantsSuccess {
    Status200(models::ListAssistantResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_feedback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFeedbackSuccess {
    Status200(models::ListFeedbacksResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_knowledge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListKnowledgeSuccess {
    Status200(models::ListKnowledgeResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_knowledge_by_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListKnowledgeByAssistantSuccess {
    Status200(models::ListKnowledgeByAssistantResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_knowledge_chunks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListKnowledgeChunksSuccess {
    Status200(models::ListKnowledgeChunksResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessagesSuccess {
    Status200(models::ListMessagesResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_policies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPoliciesSuccess {
    Status200(models::ListPoliciesResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSessionsSuccess {
    Status200(models::ListSessionsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_tools`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListToolsSuccess {
    Status200(models::ListToolsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_tools_by_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListToolsByAssistantSuccess {
    Status200(models::ListToolsByAssistantResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAssistantSuccess {
    Status200(models::AssistantsPeriodV1PeriodServicePeriodAssistant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_knowledge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateKnowledgeSuccess {
    Status200(models::AssistantsPeriodV1PeriodServicePeriodKnowledge),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_tool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateToolSuccess {
    Status200(models::AssistantsPeriodV1PeriodServicePeriodTool),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_assistant_knowledge_attachment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssistantKnowledgeAttachmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_assistant_tool_attachment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssistantToolAttachmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_feedback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFeedbackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_knowledge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateKnowledgeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_tool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateToolError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_assistant_knowledge_attachment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAssistantKnowledgeAttachmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_assistant_tool_attachment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAssistantToolAttachmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_knowledge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteKnowledgeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_tool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteToolError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_knowledge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchKnowledgeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_knowledge_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchKnowledgeStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_tool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchToolError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_assistants`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAssistantsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_feedback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFeedbackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_knowledge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListKnowledgeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_knowledge_by_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListKnowledgeByAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_knowledge_chunks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListKnowledgeChunksError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessagesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_policies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPoliciesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSessionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_tools`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListToolsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_tools_by_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListToolsByAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_assistant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_knowledge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateKnowledgeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_tool`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateToolError {
    UnknownValue(serde_json::Value),
}


/// create an assistant
pub async fn create_assistant(configuration: &configuration::Configuration, params: CreateAssistantParams) -> Result<ResponseContent<CreateAssistantSuccess>, Error<CreateAssistantError>> {

    let uri_str = format!("{}/v1/Assistants", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&params.assistants_period_v1_period_service_period_create_assistant_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateAssistantSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAssistantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Attach Knowledge to Assistant
pub async fn create_assistant_knowledge_attachment(configuration: &configuration::Configuration, params: CreateAssistantKnowledgeAttachmentParams) -> Result<ResponseContent<CreateAssistantKnowledgeAttachmentSuccess>, Error<CreateAssistantKnowledgeAttachmentError>> {

    let uri_str = format!("{}/v1/Assistants/{assistantId}/Knowledge/{id}", configuration.base_path, assistantId=crate::apis::urlencode(params.assistant_id), id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateAssistantKnowledgeAttachmentSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAssistantKnowledgeAttachmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Attach Tool to Assistant
pub async fn create_assistant_tool_attachment(configuration: &configuration::Configuration, params: CreateAssistantToolAttachmentParams) -> Result<ResponseContent<CreateAssistantToolAttachmentSuccess>, Error<CreateAssistantToolAttachmentError>> {

    let uri_str = format!("{}/v1/Assistants/{assistantId}/Tools/{id}", configuration.base_path, assistantId=crate::apis::urlencode(params.assistant_id), id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateAssistantToolAttachmentSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAssistantToolAttachmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create feedback
pub async fn create_feedback(configuration: &configuration::Configuration, params: CreateFeedbackParams) -> Result<ResponseContent<CreateFeedbackSuccess>, Error<CreateFeedbackError>> {

    let uri_str = format!("{}/v1/Assistants/{id}/Feedbacks", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&params.assistants_period_v1_period_service_period_create_feedback_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateFeedbackSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFeedbackError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create knowledge
pub async fn create_knowledge(configuration: &configuration::Configuration, params: CreateKnowledgeParams) -> Result<ResponseContent<CreateKnowledgeSuccess>, Error<CreateKnowledgeError>> {

    let uri_str = format!("{}/v1/Knowledge", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&params.assistants_period_v1_period_service_period_create_knowledge_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateKnowledgeSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateKnowledgeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// send a message
pub async fn create_message(configuration: &configuration::Configuration, params: CreateMessageParams) -> Result<ResponseContent<CreateMessageSuccess>, Error<CreateMessageError>> {

    let uri_str = format!("{}/v1/Assistants/{id}/Messages", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&params.assistants_period_v1_period_service_period_assistant_send_message_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateMessageSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create tool
pub async fn create_tool(configuration: &configuration::Configuration, params: CreateToolParams) -> Result<ResponseContent<CreateToolSuccess>, Error<CreateToolError>> {

    let uri_str = format!("{}/v1/Tools", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&params.assistants_period_v1_period_service_period_create_tool_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateToolSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateToolError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// delete an assistant
pub async fn delete_assistant(configuration: &configuration::Configuration, params: DeleteAssistantParams) -> Result<ResponseContent<DeleteAssistantSuccess>, Error<DeleteAssistantError>> {

    let uri_str = format!("{}/v1/Assistants/{id}", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteAssistantSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteAssistantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Detach Knowledge to Assistant
pub async fn delete_assistant_knowledge_attachment(configuration: &configuration::Configuration, params: DeleteAssistantKnowledgeAttachmentParams) -> Result<ResponseContent<DeleteAssistantKnowledgeAttachmentSuccess>, Error<DeleteAssistantKnowledgeAttachmentError>> {

    let uri_str = format!("{}/v1/Assistants/{assistantId}/Knowledge/{id}", configuration.base_path, assistantId=crate::apis::urlencode(params.assistant_id), id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteAssistantKnowledgeAttachmentSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteAssistantKnowledgeAttachmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Detach Tool to Assistant
pub async fn delete_assistant_tool_attachment(configuration: &configuration::Configuration, params: DeleteAssistantToolAttachmentParams) -> Result<ResponseContent<DeleteAssistantToolAttachmentSuccess>, Error<DeleteAssistantToolAttachmentError>> {

    let uri_str = format!("{}/v1/Assistants/{assistantId}/Tools/{id}", configuration.base_path, assistantId=crate::apis::urlencode(params.assistant_id), id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteAssistantToolAttachmentSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteAssistantToolAttachmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete knowledge
pub async fn delete_knowledge(configuration: &configuration::Configuration, params: DeleteKnowledgeParams) -> Result<ResponseContent<DeleteKnowledgeSuccess>, Error<DeleteKnowledgeError>> {

    let uri_str = format!("{}/v1/Knowledge/{id}", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteKnowledgeSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteKnowledgeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// delete a tool
pub async fn delete_tool(configuration: &configuration::Configuration, params: DeleteToolParams) -> Result<ResponseContent<DeleteToolSuccess>, Error<DeleteToolError>> {

    let uri_str = format!("{}/v1/Tools/{id}", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteToolSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteToolError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// get an assistant
pub async fn fetch_assistant(configuration: &configuration::Configuration, params: FetchAssistantParams) -> Result<ResponseContent<FetchAssistantSuccess>, Error<FetchAssistantError>> {

    let uri_str = format!("{}/v1/Assistants/{id}", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<FetchAssistantSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchAssistantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get knowledge
pub async fn fetch_knowledge(configuration: &configuration::Configuration, params: FetchKnowledgeParams) -> Result<ResponseContent<FetchKnowledgeSuccess>, Error<FetchKnowledgeError>> {

    let uri_str = format!("{}/v1/Knowledge/{id}", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<FetchKnowledgeSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchKnowledgeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get knowledge status
pub async fn fetch_knowledge_status(configuration: &configuration::Configuration, params: FetchKnowledgeStatusParams) -> Result<ResponseContent<FetchKnowledgeStatusSuccess>, Error<FetchKnowledgeStatusError>> {

    let uri_str = format!("{}/v1/Knowledge/{id}/Status", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<FetchKnowledgeStatusSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchKnowledgeStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// get a session
pub async fn fetch_session(configuration: &configuration::Configuration, params: FetchSessionParams) -> Result<ResponseContent<FetchSessionSuccess>, Error<FetchSessionError>> {

    let uri_str = format!("{}/v1/Sessions/{id}", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<FetchSessionSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get tool
pub async fn fetch_tool(configuration: &configuration::Configuration, params: FetchToolParams) -> Result<ResponseContent<FetchToolSuccess>, Error<FetchToolError>> {

    let uri_str = format!("{}/v1/Tools/{id}", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<FetchToolSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchToolError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// list assistants
pub async fn list_assistants(configuration: &configuration::Configuration, params: ListAssistantsParams) -> Result<ResponseContent<ListAssistantsSuccess>, Error<ListAssistantsError>> {

    let uri_str = format!("{}/v1/Assistants", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListAssistantsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAssistantsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List feedbacks
pub async fn list_feedback(configuration: &configuration::Configuration, params: ListFeedbackParams) -> Result<ResponseContent<ListFeedbackSuccess>, Error<ListFeedbackError>> {

    let uri_str = format!("{}/v1/Assistants/{id}/Feedbacks", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListFeedbackSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListFeedbackError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all knowledge
pub async fn list_knowledge(configuration: &configuration::Configuration, params: ListKnowledgeParams) -> Result<ResponseContent<ListKnowledgeSuccess>, Error<ListKnowledgeError>> {

    let uri_str = format!("{}/v1/Knowledge", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.assistant_id {
        req_builder = req_builder.query(&[("AssistantId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListKnowledgeSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListKnowledgeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all knowledge for an Assistant
pub async fn list_knowledge_by_assistant(configuration: &configuration::Configuration, params: ListKnowledgeByAssistantParams) -> Result<ResponseContent<ListKnowledgeByAssistantSuccess>, Error<ListKnowledgeByAssistantError>> {

    let uri_str = format!("{}/v1/Assistants/{assistantId}/Knowledge", configuration.base_path, assistantId=crate::apis::urlencode(params.assistant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListKnowledgeByAssistantSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListKnowledgeByAssistantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List knowledge chunks
pub async fn list_knowledge_chunks(configuration: &configuration::Configuration, params: ListKnowledgeChunksParams) -> Result<ResponseContent<ListKnowledgeChunksSuccess>, Error<ListKnowledgeChunksError>> {

    let uri_str = format!("{}/v1/Knowledge/{id}/Chunks", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListKnowledgeChunksSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListKnowledgeChunksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List messages
pub async fn list_messages(configuration: &configuration::Configuration, params: ListMessagesParams) -> Result<ResponseContent<ListMessagesSuccess>, Error<ListMessagesError>> {

    let uri_str = format!("{}/v1/Sessions/{sessionId}/Messages", configuration.base_path, sessionId=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListMessagesSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListMessagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List policies
pub async fn list_policies(configuration: &configuration::Configuration, params: ListPoliciesParams) -> Result<ResponseContent<ListPoliciesSuccess>, Error<ListPoliciesError>> {

    let uri_str = format!("{}/v1/Policies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.tool_id {
        req_builder = req_builder.query(&[("ToolId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.knowledge_id {
        req_builder = req_builder.query(&[("KnowledgeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListPoliciesSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPoliciesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List sessions
pub async fn list_sessions(configuration: &configuration::Configuration, params: ListSessionsParams) -> Result<ResponseContent<ListSessionsSuccess>, Error<ListSessionsError>> {

    let uri_str = format!("{}/v1/Sessions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListSessionsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListSessionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List tools
pub async fn list_tools(configuration: &configuration::Configuration, params: ListToolsParams) -> Result<ResponseContent<ListToolsSuccess>, Error<ListToolsError>> {

    let uri_str = format!("{}/v1/Tools", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.assistant_id {
        req_builder = req_builder.query(&[("AssistantId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListToolsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListToolsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List tools for an Assistant
pub async fn list_tools_by_assistant(configuration: &configuration::Configuration, params: ListToolsByAssistantParams) -> Result<ResponseContent<ListToolsByAssistantSuccess>, Error<ListToolsByAssistantError>> {

    let uri_str = format!("{}/v1/Assistants/{assistantId}/Tools", configuration.base_path, assistantId=crate::apis::urlencode(params.assistant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListToolsByAssistantSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListToolsByAssistantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// update an assistant
pub async fn update_assistant(configuration: &configuration::Configuration, params: UpdateAssistantParams) -> Result<ResponseContent<UpdateAssistantSuccess>, Error<UpdateAssistantError>> {

    let uri_str = format!("{}/v1/Assistants/{id}", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&params.assistants_period_v1_period_service_period_update_assistant_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<UpdateAssistantSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateAssistantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update knowledge
pub async fn update_knowledge(configuration: &configuration::Configuration, params: UpdateKnowledgeParams) -> Result<ResponseContent<UpdateKnowledgeSuccess>, Error<UpdateKnowledgeError>> {

    let uri_str = format!("{}/v1/Knowledge/{id}", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&params.assistants_period_v1_period_service_period_update_knowledge_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<UpdateKnowledgeSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateKnowledgeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update tool
pub async fn update_tool(configuration: &configuration::Configuration, params: UpdateToolParams) -> Result<ResponseContent<UpdateToolSuccess>, Error<UpdateToolError>> {

    let uri_str = format!("{}/v1/Tools/{id}", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&params.assistants_period_v1_period_service_period_update_tool_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<UpdateToolSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateToolError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

