/*
 * Twilio - Api
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`create_participant`]
#[derive(Clone, Debug)]
pub struct CreateParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The SID of the participant's conference.
    pub conference_sid: String,
    /// The phone number, Client identifier, or username portion of SIP address that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). Client identifiers are formatted `client:name`. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `from` must also be a phone number. If `to` is sip address, this value of `from` should be a username portion to be used to populate the P-Asserted-Identity header that is passed to the SIP endpoint.
    pub from: String,
    /// The phone number, SIP address, or Client identifier that received this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). SIP addresses are formatted as `sip:name@company.com`. Client identifiers are formatted `client:name`. [Custom parameters](https://www.twilio.com/docs/voice/api/conference-participant-resource#custom-parameters) may also be specified.
    pub to: String,
    /// The URL we should call using the `status_callback_method` to send status information to your application.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `GET` and `POST` and defaults to `POST`.
    pub status_callback_method: Option<String>,
    /// The conference state changes that should generate a call to `status_callback`. Can be: `initiated`, `ringing`, `answered`, and `completed`. Separate multiple values with a space. The default value is `completed`.
    pub status_callback_event: Option<Vec<String>>,
    /// A label for this participant. If one is supplied, it may subsequently be used to fetch, update or delete the participant.
    pub label: Option<String>,
    /// The number of seconds that we should allow the phone to ring before assuming there is no answer. Can be an integer between `5` and `600`, inclusive. The default value is `60`. We always add a 5-second timeout buffer to outgoing calls, so  value of 10 would result in an actual timeout that was closer to 15 seconds.
    pub timeout: Option<i32>,
    /// Whether to record the participant and their conferences, including the time between conferences. Can be `true` or `false` and the default is `false`.
    pub record: Option<bool>,
    /// Whether the agent is muted in the conference. Can be `true` or `false` and the default is `false`.
    pub muted: Option<bool>,
    /// Whether to play a notification beep to the conference when the participant joins. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
    pub beep: Option<String>,
    /// Whether to start the conference when the participant joins, if it has not already started. Can be: `true` or `false` and the default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
    pub start_conference_on_enter: Option<bool>,
    /// Whether to end the conference when the participant leaves. Can be: `true` or `false` and defaults to `false`.
    pub end_conference_on_exit: Option<bool>,
    /// The URL that Twilio calls using the `wait_method` before the conference has started. The URL may return an MP3 file, a WAV file, or a TwiML document. The default value is the URL of our standard hold music. If you do not want anything to play while waiting for the conference to start, specify an empty string by setting `wait_url` to `''`. For more details on the allowable verbs within the `waitUrl`, see the `waitUrl` attribute in the [<Conference> TwiML instruction](https://www.twilio.com/docs/voice/twiml/conference#attributes-waiturl).
    pub wait_url: Option<String>,
    /// The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
    pub wait_method: Option<String>,
    /// Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. Can be: `true` or `false` and defaults to `true`.
    pub early_media: Option<bool>,
    /// The maximum number of participants in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
    pub max_participants: Option<i32>,
    /// Whether to record the conference the participant is joining. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
    pub conference_record: Option<String>,
    /// Whether to trim leading and trailing silence from the conference recording. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
    pub conference_trim: Option<String>,
    /// The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
    pub conference_status_callback: Option<String>,
    /// The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub conference_status_callback_method: Option<String>,
    /// The conference state changes that should generate a call to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `modify`, `speaker`, and `announcement`. Separate multiple values with a space. Defaults to `start end`.
    pub conference_status_callback_event: Option<Vec<String>>,
    /// The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
    pub recording_channels: Option<String>,
    /// The URL that we should call using the `recording_status_callback_method` when the recording status changes.
    pub recording_status_callback: Option<String>,
    /// The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub recording_status_callback_method: Option<String>,
    /// The SIP username used for authentication.
    pub sip_auth_username: Option<String>,
    /// The SIP password for authentication.
    pub sip_auth_password: Option<String>,
    /// The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `us2`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
    pub region: Option<String>,
    /// The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
    pub conference_recording_status_callback: Option<String>,
    /// The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub conference_recording_status_callback_method: Option<String>,
    /// The recording state changes that should generate a call to `recording_status_callback`. Can be: `started`, `in-progress`, `paused`, `resumed`, `stopped`, `completed`, `failed`, and `absent`. Separate multiple values with a space, ex: `'in-progress completed failed'`.
    pub recording_status_callback_event: Option<Vec<String>>,
    /// The conference recording state changes that generate a call to `conference_recording_status_callback`. Can be: `in-progress`, `completed`, `failed`, and `absent`. Separate multiple values with a space, ex: `'in-progress completed failed'`
    pub conference_recording_status_callback_event: Option<Vec<String>>,
    /// Whether the participant is coaching another call. Can be: `true` or `false`. If not present, defaults to `false` unless `call_sid_to_coach` is defined. If `true`, `call_sid_to_coach` must be defined.
    pub coaching: Option<bool>,
    /// The SID of the participant who is being `coached`. The participant being coached is the only participant who can hear the participant who is `coaching`.
    pub call_sid_to_coach: Option<String>,
    /// Jitter buffer size for the connecting participant. Twilio will use this setting to apply Jitter Buffer before participant's audio is mixed into the conference. Can be: `off`, `small`, `medium`, and `large`. Default to `large`.
    pub jitter_buffer_size: Option<String>,
    /// The SID of a BYOC (Bring Your Own Carrier) trunk to route this call with. Note that `byoc` is only meaningful when `to` is a phone number; it will otherwise be ignored. (Beta)
    pub byoc: Option<String>,
    /// The phone number, Client identifier, or username portion of SIP address that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). Client identifiers are formatted `client:name`. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `callerId` must also be a phone number. If `to` is sip address, this value of `callerId` should be a username portion to be used to populate the From header that is passed to the SIP endpoint.
    pub caller_id: Option<String>,
    /// The Reason for the outgoing call. Use it to specify the purpose of the call that is presented on the called party's phone. (Branded Calls Beta)
    pub call_reason: Option<String>,
    /// The audio track to record for the call. Can be: `inbound`, `outbound` or `both`. The default is `both`. `inbound` records the audio that is received by Twilio. `outbound` records the audio that is sent from Twilio. `both` records the audio that is received and sent by Twilio.
    pub recording_track: Option<String>,
    /// The maximum duration of the call in seconds. Constraints depend on account and configuration.
    pub time_limit: Option<i32>,
    /// Whether to detect if a human, answering machine, or fax has picked up the call. Can be: `Enable` or `DetectMessageEnd`. Use `Enable` if you would like us to return `AnsweredBy` as soon as the called party is identified. Use `DetectMessageEnd`, if you would like to leave a message on an answering machine. For more information, see [Answering Machine Detection](https://www.twilio.com/docs/voice/answering-machine-detection).
    pub machine_detection: Option<String>,
    /// The number of seconds that we should attempt to detect an answering machine before timing out and sending a voice request with `AnsweredBy` of `unknown`. The default timeout is 30 seconds.
    pub machine_detection_timeout: Option<i32>,
    /// The number of milliseconds that is used as the measuring stick for the length of the speech activity, where durations lower than this value will be interpreted as a human and longer than this value as a machine. Possible Values: 1000-6000. Default: 2400.
    pub machine_detection_speech_threshold: Option<i32>,
    /// The number of milliseconds of silence after speech activity at which point the speech activity is considered complete. Possible Values: 500-5000. Default: 1200.
    pub machine_detection_speech_end_threshold: Option<i32>,
    /// The number of milliseconds of initial silence after which an `unknown` AnsweredBy result will be returned. Possible Values: 2000-10000. Default: 5000.
    pub machine_detection_silence_timeout: Option<i32>,
    /// The URL that we should call using the `amd_status_callback_method` to notify customer application whether the call was answered by human, machine or fax.
    pub amd_status_callback: Option<String>,
    /// The HTTP method we should use when calling the `amd_status_callback` URL. Can be: `GET` or `POST` and the default is `POST`.
    pub amd_status_callback_method: Option<String>,
    /// Whether to trim any leading and trailing silence from the participant recording. Can be: `trim-silence` or `do-not-trim` and the default is `trim-silence`.
    pub trim: Option<String>,
    /// A token string needed to invoke a forwarded call. A call_token is generated when an incoming call is received on a Twilio number. Pass an incoming call's call_token value to a forwarded call via the call_token parameter when creating a new call. A forwarded call should bear the same CallerID of the original incoming call.
    pub call_token: Option<String>,
}

/// struct for passing parameters to the method [`delete_participant`]
#[derive(Clone, Debug)]
pub struct DeleteParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resources to delete.
    pub account_sid: String,
    /// The SID of the conference with the participants to delete.
    pub conference_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID or label of the participant to delete. Non URL safe characters in a label must be percent encoded, for example, a space character is represented as %20.
    pub call_sid: String,
}

/// struct for passing parameters to the method [`fetch_participant`]
#[derive(Clone, Debug)]
pub struct FetchParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resource to fetch.
    pub account_sid: String,
    /// The SID of the conference with the participant to fetch.
    pub conference_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID or label of the participant to fetch. Non URL safe characters in a label must be percent encoded, for example, a space character is represented as %20.
    pub call_sid: String,
}

/// struct for passing parameters to the method [`list_participant`]
#[derive(Clone, Debug)]
pub struct ListParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resources to read.
    pub account_sid: String,
    /// The SID of the conference with the participants to read.
    pub conference_sid: String,
    /// Whether to return only participants that are muted. Can be: `true` or `false`.
    pub muted: Option<bool>,
    /// Whether to return only participants that are on hold. Can be: `true` or `false`.
    pub hold: Option<bool>,
    /// Whether to return only participants who are coaching another call. Can be: `true` or `false`.
    pub coaching: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i64>,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>,
}

/// struct for passing parameters to the method [`update_participant`]
#[derive(Clone, Debug)]
pub struct UpdateParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resources to update.
    pub account_sid: String,
    /// The SID of the conference with the participant to update.
    pub conference_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID or label of the participant to update. Non URL safe characters in a label must be percent encoded, for example, a space character is represented as %20.
    pub call_sid: String,
    /// Whether the participant should be muted. Can be `true` or `false`. `true` will mute the participant, and `false` will un-mute them. Anything value other than `true` or `false` is interpreted as `false`.
    pub muted: Option<bool>,
    /// Whether the participant should be on hold. Can be: `true` or `false`. `true` puts the participant on hold, and `false` lets them rejoin the conference.
    pub hold: Option<bool>,
    /// The URL we call using the `hold_method` for music that plays when the participant is on hold. The URL may return an MP3 file, a WAV file, or a TwiML document that contains `<Play>`, `<Say>`, `<Pause>`, or `<Redirect>` verbs.
    pub hold_url: Option<String>,
    /// The HTTP method we should use to call `hold_url`. Can be: `GET` or `POST` and the default is `GET`.
    pub hold_method: Option<String>,
    /// The URL we call using the `announce_method` for an announcement to the participant. The URL may return an MP3 file, a WAV file, or a TwiML document that contains `<Play>`, `<Say>`, `<Pause>`, or `<Redirect>` verbs.
    pub announce_url: Option<String>,
    /// The HTTP method we should use to call `announce_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub announce_method: Option<String>,
    /// The URL that Twilio calls using the `wait_method` before the conference has started. The URL may return an MP3 file, a WAV file, or a TwiML document. The default value is the URL of our standard hold music. If you do not want anything to play while waiting for the conference to start, specify an empty string by setting `wait_url` to `''`. For more details on the allowable verbs within the `waitUrl`, see the `waitUrl` attribute in the [<Conference> TwiML instruction](https://www.twilio.com/docs/voice/twiml/conference#attributes-waiturl).
    pub wait_url: Option<String>,
    /// The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
    pub wait_method: Option<String>,
    /// Whether to play a notification beep to the conference when the participant exits. Can be: `true` or `false`.
    pub beep_on_exit: Option<bool>,
    /// Whether to end the conference when the participant leaves. Can be: `true` or `false` and defaults to `false`.
    pub end_conference_on_exit: Option<bool>,
    /// Whether the participant is coaching another call. Can be: `true` or `false`. If not present, defaults to `false` unless `call_sid_to_coach` is defined. If `true`, `call_sid_to_coach` must be defined.
    pub coaching: Option<bool>,
    /// The SID of the participant who is being `coached`. The participant being coached is the only participant who can hear the participant who is `coaching`.
    pub call_sid_to_coach: Option<String>,
}

/// struct for typed successes of method [`create_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateParticipantSuccess {
    Status201(models::ApiPeriodV2010PeriodAccountPeriodConferencePeriodParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteParticipantSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchParticipantSuccess {
    Status200(models::ApiPeriodV2010PeriodAccountPeriodConferencePeriodParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListParticipantSuccess {
    Status200(models::ListParticipantResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateParticipantSuccess {
    Status200(models::ApiPeriodV2010PeriodAccountPeriodConferencePeriodParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateParticipantError {
    UnknownValue(serde_json::Value),
}

///
pub async fn create_participant(
    configuration: &configuration::Configuration,
    params: CreateParticipantParams,
) -> Result<ResponseContent<CreateParticipantSuccess>, Error<CreateParticipantError>> {
    let uri_str = format!(
        "{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json",
        configuration.base_path,
        AccountSid = crate::apis::urlencode(params.account_sid),
        ConferenceSid = crate::apis::urlencode(params.conference_sid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("From", params.from.to_string());
    multipart_form_params.insert("To", params.to.to_string());
    if let Some(param_value) = params.status_callback {
        multipart_form_params.insert("StatusCallback", param_value.to_string());
    }
    if let Some(param_value) = params.status_callback_method {
        multipart_form_params.insert("StatusCallbackMethod", param_value.to_string());
    }
    if let Some(param_value) = params.status_callback_event {
        multipart_form_params.insert(
            "StatusCallbackEvent",
            param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(param_value) = params.label {
        multipart_form_params.insert("Label", param_value.to_string());
    }
    if let Some(param_value) = params.timeout {
        multipart_form_params.insert("Timeout", param_value.to_string());
    }
    if let Some(param_value) = params.record {
        multipart_form_params.insert("Record", param_value.to_string());
    }
    if let Some(param_value) = params.muted {
        multipart_form_params.insert("Muted", param_value.to_string());
    }
    if let Some(param_value) = params.beep {
        multipart_form_params.insert("Beep", param_value.to_string());
    }
    if let Some(param_value) = params.start_conference_on_enter {
        multipart_form_params.insert("StartConferenceOnEnter", param_value.to_string());
    }
    if let Some(param_value) = params.end_conference_on_exit {
        multipart_form_params.insert("EndConferenceOnExit", param_value.to_string());
    }
    if let Some(param_value) = params.wait_url {
        multipart_form_params.insert("WaitUrl", param_value.to_string());
    }
    if let Some(param_value) = params.wait_method {
        multipart_form_params.insert("WaitMethod", param_value.to_string());
    }
    if let Some(param_value) = params.early_media {
        multipart_form_params.insert("EarlyMedia", param_value.to_string());
    }
    if let Some(param_value) = params.max_participants {
        multipart_form_params.insert("MaxParticipants", param_value.to_string());
    }
    if let Some(param_value) = params.conference_record {
        multipart_form_params.insert("ConferenceRecord", param_value.to_string());
    }
    if let Some(param_value) = params.conference_trim {
        multipart_form_params.insert("ConferenceTrim", param_value.to_string());
    }
    if let Some(param_value) = params.conference_status_callback {
        multipart_form_params.insert("ConferenceStatusCallback", param_value.to_string());
    }
    if let Some(param_value) = params.conference_status_callback_method {
        multipart_form_params.insert("ConferenceStatusCallbackMethod", param_value.to_string());
    }
    if let Some(param_value) = params.conference_status_callback_event {
        multipart_form_params.insert(
            "ConferenceStatusCallbackEvent",
            param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(param_value) = params.recording_channels {
        multipart_form_params.insert("RecordingChannels", param_value.to_string());
    }
    if let Some(param_value) = params.recording_status_callback {
        multipart_form_params.insert("RecordingStatusCallback", param_value.to_string());
    }
    if let Some(param_value) = params.recording_status_callback_method {
        multipart_form_params.insert("RecordingStatusCallbackMethod", param_value.to_string());
    }
    if let Some(param_value) = params.sip_auth_username {
        multipart_form_params.insert("SipAuthUsername", param_value.to_string());
    }
    if let Some(param_value) = params.sip_auth_password {
        multipart_form_params.insert("SipAuthPassword", param_value.to_string());
    }
    if let Some(param_value) = params.region {
        multipart_form_params.insert("Region", param_value.to_string());
    }
    if let Some(param_value) = params.conference_recording_status_callback {
        multipart_form_params.insert("ConferenceRecordingStatusCallback", param_value.to_string());
    }
    if let Some(param_value) = params.conference_recording_status_callback_method {
        multipart_form_params.insert(
            "ConferenceRecordingStatusCallbackMethod",
            param_value.to_string(),
        );
    }
    if let Some(param_value) = params.recording_status_callback_event {
        multipart_form_params.insert(
            "RecordingStatusCallbackEvent",
            param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(param_value) = params.conference_recording_status_callback_event {
        multipart_form_params.insert(
            "ConferenceRecordingStatusCallbackEvent",
            param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(param_value) = params.coaching {
        multipart_form_params.insert("Coaching", param_value.to_string());
    }
    if let Some(param_value) = params.call_sid_to_coach {
        multipart_form_params.insert("CallSidToCoach", param_value.to_string());
    }
    if let Some(param_value) = params.jitter_buffer_size {
        multipart_form_params.insert("JitterBufferSize", param_value.to_string());
    }
    if let Some(param_value) = params.byoc {
        multipart_form_params.insert("Byoc", param_value.to_string());
    }
    if let Some(param_value) = params.caller_id {
        multipart_form_params.insert("CallerId", param_value.to_string());
    }
    if let Some(param_value) = params.call_reason {
        multipart_form_params.insert("CallReason", param_value.to_string());
    }
    if let Some(param_value) = params.recording_track {
        multipart_form_params.insert("RecordingTrack", param_value.to_string());
    }
    if let Some(param_value) = params.time_limit {
        multipart_form_params.insert("TimeLimit", param_value.to_string());
    }
    if let Some(param_value) = params.machine_detection {
        multipart_form_params.insert("MachineDetection", param_value.to_string());
    }
    if let Some(param_value) = params.machine_detection_timeout {
        multipart_form_params.insert("MachineDetectionTimeout", param_value.to_string());
    }
    if let Some(param_value) = params.machine_detection_speech_threshold {
        multipart_form_params.insert("MachineDetectionSpeechThreshold", param_value.to_string());
    }
    if let Some(param_value) = params.machine_detection_speech_end_threshold {
        multipart_form_params.insert(
            "MachineDetectionSpeechEndThreshold",
            param_value.to_string(),
        );
    }
    if let Some(param_value) = params.machine_detection_silence_timeout {
        multipart_form_params.insert("MachineDetectionSilenceTimeout", param_value.to_string());
    }
    if let Some(param_value) = params.amd_status_callback {
        multipart_form_params.insert("AmdStatusCallback", param_value.to_string());
    }
    if let Some(param_value) = params.amd_status_callback_method {
        multipart_form_params.insert("AmdStatusCallbackMethod", param_value.to_string());
    }
    if let Some(param_value) = params.trim {
        multipart_form_params.insert("Trim", param_value.to_string());
    }
    if let Some(param_value) = params.call_token {
        multipart_form_params.insert("CallToken", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateParticipantSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateParticipantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Kick a participant from a given conference
pub async fn delete_participant(
    configuration: &configuration::Configuration,
    params: DeleteParticipantParams,
) -> Result<ResponseContent<DeleteParticipantSuccess>, Error<DeleteParticipantError>> {
    let uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json", configuration.base_path, AccountSid=crate::apis::urlencode(params.account_sid), ConferenceSid=crate::apis::urlencode(params.conference_sid), CallSid=crate::apis::urlencode(params.call_sid));
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteParticipantSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteParticipantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fetch an instance of a participant
pub async fn fetch_participant(
    configuration: &configuration::Configuration,
    params: FetchParticipantParams,
) -> Result<ResponseContent<FetchParticipantSuccess>, Error<FetchParticipantError>> {
    let uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json", configuration.base_path, AccountSid=crate::apis::urlencode(params.account_sid), ConferenceSid=crate::apis::urlencode(params.conference_sid), CallSid=crate::apis::urlencode(params.call_sid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<FetchParticipantSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchParticipantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve a list of participants belonging to the account used to make the request
pub async fn list_participant(
    configuration: &configuration::Configuration,
    params: ListParticipantParams,
) -> Result<ResponseContent<ListParticipantSuccess>, Error<ListParticipantError>> {
    let uri_str = format!(
        "{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json",
        configuration.base_path,
        AccountSid = crate::apis::urlencode(params.account_sid),
        ConferenceSid = crate::apis::urlencode(params.conference_sid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.muted {
        req_builder = req_builder.query(&[("Muted", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hold {
        req_builder = req_builder.query(&[("Hold", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.coaching {
        req_builder = req_builder.query(&[("Coaching", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListParticipantSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListParticipantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update the properties of the participant
pub async fn update_participant(
    configuration: &configuration::Configuration,
    params: UpdateParticipantParams,
) -> Result<ResponseContent<UpdateParticipantSuccess>, Error<UpdateParticipantError>> {
    let uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json", configuration.base_path, AccountSid=crate::apis::urlencode(params.account_sid), ConferenceSid=crate::apis::urlencode(params.conference_sid), CallSid=crate::apis::urlencode(params.call_sid));
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.muted {
        multipart_form_params.insert("Muted", param_value.to_string());
    }
    if let Some(param_value) = params.hold {
        multipart_form_params.insert("Hold", param_value.to_string());
    }
    if let Some(param_value) = params.hold_url {
        multipart_form_params.insert("HoldUrl", param_value.to_string());
    }
    if let Some(param_value) = params.hold_method {
        multipart_form_params.insert("HoldMethod", param_value.to_string());
    }
    if let Some(param_value) = params.announce_url {
        multipart_form_params.insert("AnnounceUrl", param_value.to_string());
    }
    if let Some(param_value) = params.announce_method {
        multipart_form_params.insert("AnnounceMethod", param_value.to_string());
    }
    if let Some(param_value) = params.wait_url {
        multipart_form_params.insert("WaitUrl", param_value.to_string());
    }
    if let Some(param_value) = params.wait_method {
        multipart_form_params.insert("WaitMethod", param_value.to_string());
    }
    if let Some(param_value) = params.beep_on_exit {
        multipart_form_params.insert("BeepOnExit", param_value.to_string());
    }
    if let Some(param_value) = params.end_conference_on_exit {
        multipart_form_params.insert("EndConferenceOnExit", param_value.to_string());
    }
    if let Some(param_value) = params.coaching {
        multipart_form_params.insert("Coaching", param_value.to_string());
    }
    if let Some(param_value) = params.call_sid_to_coach {
        multipart_form_params.insert("CallSidToCoach", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<UpdateParticipantSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateParticipantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
