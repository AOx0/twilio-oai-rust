/*
 * Twilio - Api
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`create_address`]
#[derive(Clone, Debug)]
pub struct CreateAddressParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will be responsible for the new Address resource.
    pub account_sid: String,
    /// The name to associate with the new address.
    pub customer_name: String,
    /// The number and street address of the new address.
    pub street: String,
    /// The city of the new address.
    pub city: String,
    /// The state or region of the new address.
    pub region: String,
    /// The postal code of the new address.
    pub postal_code: String,
    /// The ISO country code of the new address.
    pub iso_country: String,
    /// A descriptive string that you create to describe the new address. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// Whether to enable emergency calling on the new address. Can be: `true` or `false`.
    pub emergency_enabled: Option<bool>,
    /// Whether we should automatically correct the address. Can be: `true` or `false` and the default is `true`. If empty or `true`, we will correct the address you provide if necessary. If `false`, we won't alter the address you provide.
    pub auto_correct_address: Option<bool>,
    /// The additional number and street address of the address.
    pub street_secondary: Option<String>,
}

/// struct for passing parameters to the method [`delete_address`]
#[derive(Clone, Debug)]
pub struct DeleteAddressParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is responsible for the Address resource to delete.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Address resource to delete.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_address`]
#[derive(Clone, Debug)]
pub struct FetchAddressParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is responsible for the Address resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Address resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`list_address`]
#[derive(Clone, Debug)]
pub struct ListAddressParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is responsible for the Address resource to read.
    pub account_sid: String,
    /// The `customer_name` of the Address resources to read.
    pub customer_name: Option<String>,
    /// The string that identifies the Address resources to read.
    pub friendly_name: Option<String>,
    /// Whether the address can be associated to a number for emergency calling.
    pub emergency_enabled: Option<bool>,
    /// The ISO country code of the Address resources to read.
    pub iso_country: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i64>,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>,
}

/// struct for passing parameters to the method [`update_address`]
#[derive(Clone, Debug)]
pub struct UpdateAddressParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is responsible for the Address resource to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Address resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the new address. It can be up to 64 characters long for Regulatory Compliance addresses and 32 characters long for Emergency addresses.
    pub friendly_name: Option<String>,
    /// The name to associate with the address.
    pub customer_name: Option<String>,
    /// The number and street address of the address.
    pub street: Option<String>,
    /// The city of the address.
    pub city: Option<String>,
    /// The state or region of the address.
    pub region: Option<String>,
    /// The postal code of the address.
    pub postal_code: Option<String>,
    /// Whether to enable emergency calling on the address. Can be: `true` or `false`.
    pub emergency_enabled: Option<bool>,
    /// Whether we should automatically correct the address. Can be: `true` or `false` and the default is `true`. If empty or `true`, we will correct the address you provide if necessary. If `false`, we won't alter the address you provide.
    pub auto_correct_address: Option<bool>,
    /// The additional number and street address of the address.
    pub street_secondary: Option<String>,
}

/// struct for typed successes of method [`create_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAddressSuccess {
    Status201(models::ApiPeriodV2010PeriodAccountPeriodAddress),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAddressSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAddressSuccess {
    Status200(models::ApiPeriodV2010PeriodAccountPeriodAddress),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAddressSuccess {
    Status200(models::ListAddressResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAddressSuccess {
    Status200(models::ApiPeriodV2010PeriodAccountPeriodAddress),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAddressError {
    UnknownValue(serde_json::Value),
}

///
pub async fn create_address(
    configuration: &configuration::Configuration,
    params: CreateAddressParams,
) -> Result<ResponseContent<CreateAddressSuccess>, Error<CreateAddressError>> {
    let uri_str = format!(
        "{}/2010-04-01/Accounts/{AccountSid}/Addresses.json",
        configuration.base_path,
        AccountSid = crate::apis::urlencode(params.account_sid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("CustomerName", params.customer_name.to_string());
    multipart_form_params.insert("Street", params.street.to_string());
    multipart_form_params.insert("City", params.city.to_string());
    multipart_form_params.insert("Region", params.region.to_string());
    multipart_form_params.insert("PostalCode", params.postal_code.to_string());
    multipart_form_params.insert("IsoCountry", params.iso_country.to_string());
    if let Some(param_value) = params.friendly_name {
        multipart_form_params.insert("FriendlyName", param_value.to_string());
    }
    if let Some(param_value) = params.emergency_enabled {
        multipart_form_params.insert("EmergencyEnabled", param_value.to_string());
    }
    if let Some(param_value) = params.auto_correct_address {
        multipart_form_params.insert("AutoCorrectAddress", param_value.to_string());
    }
    if let Some(param_value) = params.street_secondary {
        multipart_form_params.insert("StreetSecondary", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateAddressSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

///
pub async fn delete_address(
    configuration: &configuration::Configuration,
    params: DeleteAddressParams,
) -> Result<ResponseContent<DeleteAddressSuccess>, Error<DeleteAddressError>> {
    let uri_str = format!(
        "{}/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json",
        configuration.base_path,
        AccountSid = crate::apis::urlencode(params.account_sid),
        Sid = crate::apis::urlencode(params.sid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteAddressSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

///
pub async fn fetch_address(
    configuration: &configuration::Configuration,
    params: FetchAddressParams,
) -> Result<ResponseContent<FetchAddressSuccess>, Error<FetchAddressError>> {
    let uri_str = format!(
        "{}/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json",
        configuration.base_path,
        AccountSid = crate::apis::urlencode(params.account_sid),
        Sid = crate::apis::urlencode(params.sid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<FetchAddressSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

///
pub async fn list_address(
    configuration: &configuration::Configuration,
    params: ListAddressParams,
) -> Result<ResponseContent<ListAddressSuccess>, Error<ListAddressError>> {
    let uri_str = format!(
        "{}/2010-04-01/Accounts/{AccountSid}/Addresses.json",
        configuration.base_path,
        AccountSid = crate::apis::urlencode(params.account_sid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.customer_name {
        req_builder = req_builder.query(&[("CustomerName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.friendly_name {
        req_builder = req_builder.query(&[("FriendlyName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.emergency_enabled {
        req_builder = req_builder.query(&[("EmergencyEnabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.iso_country {
        req_builder = req_builder.query(&[("IsoCountry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListAddressSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

///
pub async fn update_address(
    configuration: &configuration::Configuration,
    params: UpdateAddressParams,
) -> Result<ResponseContent<UpdateAddressSuccess>, Error<UpdateAddressError>> {
    let uri_str = format!(
        "{}/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json",
        configuration.base_path,
        AccountSid = crate::apis::urlencode(params.account_sid),
        Sid = crate::apis::urlencode(params.sid)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.friendly_name {
        multipart_form_params.insert("FriendlyName", param_value.to_string());
    }
    if let Some(param_value) = params.customer_name {
        multipart_form_params.insert("CustomerName", param_value.to_string());
    }
    if let Some(param_value) = params.street {
        multipart_form_params.insert("Street", param_value.to_string());
    }
    if let Some(param_value) = params.city {
        multipart_form_params.insert("City", param_value.to_string());
    }
    if let Some(param_value) = params.region {
        multipart_form_params.insert("Region", param_value.to_string());
    }
    if let Some(param_value) = params.postal_code {
        multipart_form_params.insert("PostalCode", param_value.to_string());
    }
    if let Some(param_value) = params.emergency_enabled {
        multipart_form_params.insert("EmergencyEnabled", param_value.to_string());
    }
    if let Some(param_value) = params.auto_correct_address {
        multipart_form_params.insert("AutoCorrectAddress", param_value.to_string());
    }
    if let Some(param_value) = params.street_secondary {
        multipart_form_params.insert("StreetSecondary", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<UpdateAddressSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent {
            status,
            content,
            entity,
        })
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
